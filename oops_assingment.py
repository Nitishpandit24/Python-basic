# -*- coding: utf-8 -*-
"""OOPS_assingment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x2XK5R1GykMz2mt9BVuw3_3yyk86tyz5

1. What are the five key concepts of Object-Oriented Programming (OOP)?

Ans: Object-Oriented Programming (OOP) is a programming paradigm that uses objects and classes to structure software. The five key concepts of OOP are:

1. Classes and Objects:
      
      Class: A blueprint for creating objects. It defines a datatype by bundling data and methods that work on the data into one single unit.
      Object: An instance of a class. It is created from a class and can have unique values for its properties.
2. Encapsulation:
  This concept involves bundling the data (variables) and the methods (functions) that operate on the data into a single unit, or class. It also restricts direct access to some of the object's components, which is a means of preventing accidental interference and misuse of the data.
3. Inheritance:
  This allows a new class to inherit properties and methods from an existing class. The new class is called a subclass (or derived class), and the existing class is called a superclass (or base class). Inheritance promotes code reusability.
4. Polymorphism:
  This allows objects to be treated as instances of their parent class rather than their actual class. The most common use of polymorphism is when a parent class reference is used to refer to a child class object. It allows one interface to be used for a general class of actions.
5. Abstraction:
  This concept involves hiding the complex implementation details and showing only the essential features of the object.
"""



"""2. Write a Python class for a `Car` with attributes for `make`, `model`, and `year`. Include a method to display
the car's information.
"""

class Car():
  def __init__(self,make,model,year):
    self.make=make
    self.model=model
    self.year=year

  def display_info(self):
    print(f"Make: {self.make}\nModel: {self.model}\nYear: {self.year}")

c1=Car("Tata","Safari","2024")

c1.display_info()

"""3. Explain the difference between instance methods and class methods. Provide an example of each.

Ans: Instance method:
  Instance methods are methods that belong to an instance of a class, i.e., an object. They operate on the data of a specific object and can access and modify its attributes.
"""

class Dog():
  def __init__(self,name,age):
    self.name=name
    self.age=age

  def show_details(self):
    print(f"My dog's name is {self.name} and is {self.age} year old")

d1=Dog("Jimmiy",105)

d1.show_details()

"""Class methods:
  Class methods, on the other hand, belong to the class itself, rather than an instance of the class. They operate on the class level and can be used to perform actions that are related to the class as a whole, rather than a specific object.
"""

class Car():
  company="TATA"

  @classmethod
  def show_details(cls):
    print(cls.company)

Car.show_details()

"""4. How does Python implement method overloading? Give an example."""

class Collage():
  def detail(self):
    print("Collage name is Pwskill")
  def detail(self,name=""):
    print("Collage name is Pwskill ",name)
  def detail(self,name="",location=""):
    print("Collage name is Pwskill ",name,location)

c1=Collage()

c1.detail()

c1.detail('Nitish')

c1.detail('Nitish','Delhi')

"""5.  What are the three types of access modifiers in Python? How are they denoted?

Ans: In Python, there are three types of access modifiers: public, protected, and private.
"""

#Public modifier:

class Greet():
  def message(self,name):
    print(f"Welcome {name}")

c1=Greet()

c1.message("Nitish")

#Private method

class Company():
  def __init__(self,name,salary):
    self.__name=name
    self.__salary=salary

  def show_details(self):
    print(f"Name: {self.__name}\nSalary: {self.__salary}")

e1=Company("Nitish",1000000)

e1.show_details()

e1.name
e1.salary
#Both are unaccessable directly

#Protected method
class Company():
  def _detail(self):
    print("Physics Wallah")

class Employee(Company):
  def __init__(self,name,salary):
    self.name=name
    self.salary=salary

  def show_details(self):
    self._detail()
    print(f"Name: {self.name}\nSalary: {self.salary}")

c1=Employee("Nitish",1000000)

c1.show_details()

c2=Company()

c2.detail()
#Unaccessible

"""6. Describe the five types of inheritance in Python. Provide a simple example of multiple inheritance.

Ans: Inheritance is a mechanism that allows one class to inherit the properties and behavior of another class. There are five types of inheritance in Python: single inheritance, multiple inheritance, multilevel inheritance, hierarchical inheritance, and hybrid inheritance.
1. Single Inheritance:
In single inheritance, a child class inherits from a single parent class. The child class inherits all the attributes and methods of the parent class.

2. Multiple Inheritance:
In multiple inheritance, a child class can inherit from multiple parent classes. This allows the child class to inherit attributes and methods from multiple sources.

3. Multilevel Inheritance:
In multilevel inheritance, a child class inherits from a parent class, which itself inherits from another parent class. This creates a hierarchy of inheritance.

4. Hierarchical Inheritance:
In hierarchical inheritance, multiple child classes inherit from a single parent class. This creates a tree-like structure of inheritance.

5. Hybrid Inheritance:
In hybrid inheritance, a combination of multiple and multilevel inheritance is used. This allows for a complex hierarchy of inheritance.
"""

#Multiple inheritance

class Dog():
  def show_dog(self):
    print("This is dog class")

class Cat():
  def show_cat(self):
    print("This is cat class")

class Animal(Dog,Cat):
  def show_animal(self):
    print("This is animal class")

a1=Animal()

a1.show_dog()
a1.show_cat()
a1.show_animal()

"""7. What is the Method Resolution Order (MRO) in Python? How can you retrieve it programmatically?

Ans: The Method Resolution Order (MRO) in Python is the order in which Python searches for a method or attribute in a class and its parent classes. It's a mechanism that determines the order of inheritance when a class has multiple base classes. The MRO is used to resolve method calls, attribute accesses, and other operations that involve inheritance.
"""

class A():
  pass

class B(A):
  pass

class C(B):
  pass

print(C.__mro__)



"""8. Create an abstract base class `Shape` with an abstract method `area()`. Then create two subclasses
`Circle` and `Rectangle` that implement the `area()` method.
"""

from abc import ABC,abstractmethod

class Shape(ABC):
  @abstractmethod
  def area(self):
    pass

class Circle(Shape):
  def __init__(self,radius):
    self.radius=radius

  def area(self):
    print( 3.14*self.radius**2)

class Rectangle(Shape):
  def __init__(self,length,breadth):
    self.length=length
    self.breadth=breadth

  def area(self):
    print( self.length*self.breadth)

circle1=Circle(5)

circle1.area()

rectangle1=Rectangle(10,5)

rectangle1.area()

"""9. Demonstrate polymorphism by creating a function that can work with different shape objects to calculate
and print their areas.



"""

# class Shape():
#   def area(self):
#     pass

class Rectangle():
  def __init__(self,length,breadth):
    self.length=length
    self.breadth=breadth

  def area(self):
    return self.length*self.breadth

class Circle():
  def __init__(self,radius):
    self.radius=radius

  def area(self):
    return 3.14*self.radius**2

class Triangle():
  def __init__(self,base,height):
    self.base=base
    self.height=height

  def area(self):
    return 0.5*self.base*self.height

def Print_area(shape):
  print(f"Area of {shape.__class__.__name__} is {shape.area()}")

rectangle=Rectangle(10,5)
circle=Circle(5)
triangle=Triangle(10,5)

Print_area(rectangle)
Print_area(circle)
Print_area(triangle)

"""10. Implement encapsulation in a `BankAccount` class with private attributes for `balance` and
`account_number`. Include methods for deposit, withdrawal, and balance inquiry.
"""

class Bank_account():
  def __init__(self,balance,account_number):
    self.__balance=balance
    self.__account_number=account_number

  def deposit(self,amount):
    self.__balance+=amount

  def withdrawal(self,amount):
    if self.__balance>=amount:
      self.__balance-=amount
    else:
      print("Insufficient balance")

  def current_balance(self):
    return self.__balance

  def account_detail(self):
    print(f"Account number: {self.__account_number}\nBalance: {self.__balance}")

c1=Bank_account(1000,123456789)

c1.deposit(1000)
c1.account_detail()

"""11. Write a class that overrides the `__str__` and `__add__` magic methods. What will these methods allow
you to do?
"""

class Over_ride():
  def __init__(self,name):
    self.name=name

  def __str__(self):
    print( f"Name: {self.name}")

  def __add__(self):
    print("This function does not add")

c1=Over_ride("nitish")

c1.__str__()

c1.__add__()

"""12. Create a decorator that measures and prints the execution time of a function."""

import time
from functools import wraps

def timeit(func):
    @wraps(func)
    def timeit_wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        total_time = end_time - start_time
        print(f'Function {func.__name__} took {total_time:.4f} seconds')
        return result
    return timeit_wrapper

@timeit
def example_function(n):
    total = sum(range(n))
    return total

example_function(1000000)

"""13. Explain the concept of the Diamond Problem in multiple inheritance. How does Python resolve it?

Ans: The Diamond Problem occurs in object-oriented programming languages that support multiple inheritance. It arises when a class inherits from two or more classes that have a common base class, forming a diamond shape in the inheritance hierarchy.


Python resolves the Diamond Problem using the Method Resolution Order (MRO), which ensures a consistent and clear method lookup process. MRO is determined using the C3 Linearization algorithm, which creates a linear order for method resolution by considering the hierarchy and dependencies between the classes.

14. Write a class method that keeps track of the number of instances created from a class.
"""

class InstanceTracker:
    instance_count = 0

    def __init__(self):
        InstanceTracker.instance_count += 1

    @classmethod
    def get_instance_count(cls):
        return cls.instance_count

obj1 = InstanceTracker()
obj2 = InstanceTracker()
obj3 = InstanceTracker()

print(InstanceTracker.get_instance_count())

"""15. Implement a static method in a class that checks if a given year is a leap year."""

class Leapyear():
  def __init__(self,year):
    self.year=year

  @staticmethod
  def check_year(year):
    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
      return True
    else:
      return False

l1=Leapyear(2024)

l1.check_year(l1.year)

